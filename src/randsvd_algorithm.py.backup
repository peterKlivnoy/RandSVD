import numpy as np
from .structured_sketch import srht_operator, slow_gaussian_operator 

def randSVD(A, k, p, q=0, sketch_type='gaussian'):
    """
    Computes the randomized SVD of a matrix A using q power iterations and 
    a specified sketch_type ('gaussian', 'srht', or 'slow_gaussian').

    A is a nxm input matrix; 
    k is the approximation rank; 
    p is the oversampling parameter; 
    q is the number of power iterations (Subspace Iteration).
    """
    rng = np.random.default_rng(seed=0)
    n, m = A.shape[0], A.shape[1]
    l = k + p

    # --- STAGE A: Find an orthonormal basis (Sketching) ---
    if sketch_type == 'gaussian':
        # Fast, compiled O(mn*l)
        omega = rng.normal(loc=0, scale=1, size=(m, l))
        Y = A @ omega
    elif sketch_type == 'srht':
        # Structured, intended O(mn log n)
        Y = srht_operator(A, l)
    elif sketch_type == 'slow_gaussian':
        # Inefficient Python loop O(mn*l), used for complexity comparison
        Y = slow_gaussian_operator(A, l)
    else:
        raise ValueError("Invalid sketch_type. Must be 'gaussian', 'srht', or 'slow_gaussian'.")
        
    # --- 3. Subspace Iteration (Power Method) for robustness ---
    for i in range(q):
        # QR on Y to get orthonormal basis Q_i (stabilization)
        Q, _ = np.linalg.qr(Y)
        
        # Apply A.T (implicit AA.T iteration)
        Y = A.T @ Q
        
        # QR on Y to get orthonormal basis Q_i+1 (stabilization)
        Q, _ = np.linalg.qr(Y)
        
        # Apply A: Y = A @ Q (final step of the power iteration)
        Y = A @ Q
    
    # 4. Compute the final orthonormal basis Q for the range of Y 
    Q, _ = np.linalg.qr(Y) 
    
    # STAGE B: Project A onto the low-dim subspace
    # 5. Form the small matrix B
    B = Q.T @ A
    
    # 6. Compute the deterministic SVD of the small matrix B
    U_delta, Sig, V_transpose = np.linalg.svd(B, full_matrices=False)
    
    # 7. Reconstruct the left singular vectors for A
    U = Q @ U_delta
    
    # 8. Truncate and Return
    U_k = U[:, :k]
    Sig_k = Sig[:k]
    V_transpose_k = V_transpose[:k, :]

    return U_k, Sig_k, V_transpose_k